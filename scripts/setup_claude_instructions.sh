#!/bin/bash
# Setup Claude Code Instructions Script
# Generates .claude/ directory from foundation and docs sources
# Parallel to setup_cursor_copies.sh but outputs Claude Code format

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Helper function to adapt .mdc file for Claude Code
adapt_mdc_for_claude() {
    local source_file="$1"
    local source_path="$2"
    
    # Read file, strip Cursor copy-header, adapt references
    # Extract frontmatter if present (between first --- and second ---)
    if head -1 "$source_file" | grep -q "^---$"; then
        # Find line number of second ---
        second_delim=$(awk '/^---$/{if(++count==2){print NR; exit}}' "$source_file")
        if [ -n "$second_delim" ]; then
            # Output frontmatter (optional for Claude)
            head -n "$second_delim" "$source_file"
            echo ""
            # Add source reference
            echo "<!-- Source: $source_path -->"
            echo ""
            # Output rest of file, skip Cursor copy-header if present
            tail -n +$((second_delim+1)) "$source_file" | \
                grep -v "^# ⚠️ *DO NOT EDIT THIS FILE DIRECTLY" | \
                grep -v "^# This is a copy of:" | \
                grep -v "^# Source of truth:" | \
                grep -v "^# To edit this rule:" | \
                grep -v "^# 1. Edit the source file:" | \
                grep -v "^# 2. Run '/setup_cursor_copies' to sync changes" | \
                grep -v "^# This file will be overwritten when running setup_cursor_copies" | \
                sed 's|\.cursor/rules|.claude/rules|g' | \
                sed 's|\.cursor/commands|.claude/skills|g' | \
                sed 's|/setup_cursor_copies|scripts/setup_claude_instructions.sh|g' | \
                sed 's|setup_cursor_copies\.sh|setup_claude_instructions.sh|g'
        else
            # No second --- found, just copy the file with adaptations
            cat "$source_file" | \
                sed 's|\.cursor/rules|.claude/rules|g' | \
                sed 's|\.cursor/commands|.claude/skills|g' | \
                sed 's|/setup_cursor_copies|scripts/setup_claude_instructions.sh|g' | \
                sed 's|setup_cursor_copies\.sh|setup_claude_instructions.sh|g'
        fi
    else
        # No frontmatter, just copy with adaptations
        echo "<!-- Source: $source_path -->"
        echo ""
        cat "$source_file" | \
            sed 's|\.cursor/rules|.claude/rules|g' | \
            sed 's|\.cursor/commands|.claude/skills|g' | \
            sed 's|/setup_cursor_copies|scripts/setup_claude_instructions.sh|g' | \
            sed 's|setup_cursor_copies\.sh|setup_claude_instructions.sh|g'
    fi
}

# Helper function to adapt command file to Claude skill format
adapt_command_to_skill() {
    local source_file="$1"
    local source_path="$2"
    local skill_name="$3"
    
    # Extract description from first markdown header
    local description=$(grep -m1 "^# " "$source_file" | sed 's/^# //')
    
    # Output skill frontmatter
    echo "---"
    echo "name: $skill_name"
    if [ -n "$description" ]; then
        echo "description: $description"
    fi
    echo "---"
    echo ""
    echo "<!-- Source: $source_path -->"
    echo ""
    
    # Output command content, strip Cursor copy-header if present, adapt references
    grep -v "^<!--" "$source_file" | \
        grep -v "^⚠️" | \
        grep -v "^This is a copy of:" | \
        grep -v "^Source of truth:" | \
        grep -v "^To edit this command:" | \
        grep -v "^1. Edit the source file" | \
        grep -v "^2. Run '/setup_cursor_copies'" | \
        grep -v "^This file will be overwritten" | \
        grep -v "^-->" | \
        sed 's|\.cursor/rules|.claude/rules|g' | \
        sed 's|\.cursor/commands|.claude/skills|g' | \
        sed 's|/setup_cursor_copies|scripts/setup_claude_instructions.sh|g' | \
        sed 's|setup_cursor_copies\.sh|setup_claude_instructions.sh|g'
}

# Find foundation directory
FOUNDATION_DIR=""
if [ -d "foundation" ]; then
    FOUNDATION_DIR="foundation"
elif [ -d "../foundation" ]; then
    FOUNDATION_DIR="../foundation"
else
    print_error "Foundation directory not found. Please run from repository root or ensure foundation is installed."
    exit 1
fi

# Check if foundation has cursor rules
RULES_DIR="$FOUNDATION_DIR/agent_instructions/cursor_rules"
COMMANDS_DIR="$FOUNDATION_DIR/agent_instructions/cursor_commands"

if [ ! -d "$RULES_DIR" ]; then
    print_error "Cursor rules directory not found: $RULES_DIR"
    exit 1
fi

if [ ! -d "$COMMANDS_DIR" ]; then
    print_error "Cursor commands directory not found: $COMMANDS_DIR"
    exit 1
fi

# Create .claude directories if they don't exist
mkdir -p .claude/rules
mkdir -p .claude/skills
mkdir -p .claude/hooks

print_info "Setting up Claude Code instructions..."
print_info "Foundation directory: $FOUNDATION_DIR"

# Remove existing generated files
print_info "Removing existing generated files..."
RULES_REMOVED=0
SKILLS_REMOVED=0

if [ -d ".claude/rules" ]; then
    for existing_file in .claude/rules/*.md .claude/rules/*.mdc; do
        if [ -f "$existing_file" ] && head -5 "$existing_file" | grep -q "<!-- Source:"; then
            rm "$existing_file"
            RULES_REMOVED=$((RULES_REMOVED + 1))
        fi
    done
fi

if [ -d ".claude/skills" ]; then
    for existing_file in .claude/skills/*.md; do
        if [ -f "$existing_file" ] && head -10 "$existing_file" | grep -q "<!-- Source:"; then
            rm "$existing_file"
            SKILLS_REMOVED=$((SKILLS_REMOVED + 1))
        fi
    done
fi

if [ $RULES_REMOVED -gt 0 ]; then
    print_info "Removed $RULES_REMOVED existing rule file(s)"
fi
if [ $SKILLS_REMOVED -gt 0 ]; then
    print_info "Removed $SKILLS_REMOVED existing skill file(s)"
fi

# Process foundation rules
print_info "Processing foundation rules..."
RULES_COPIED=0

# List of Cursor-specific rules to skip (not relevant for Claude Code)
SKIP_RULES=("cursor_rules_editing" "cursor_rules_sync" "cursor_rules_sync_requirement")

for rule_file in "$RULES_DIR"/*.mdc "$RULES_DIR"/*.md; do
    if [ -f "$rule_file" ]; then
        rule_name=$(basename "$rule_file")
        base_name="${rule_name%.*}"
        
        # Skip Cursor-specific rules
        skip=false
        for skip_pattern in "${SKIP_RULES[@]}"; do
            if [[ "$base_name" == "$skip_pattern" ]]; then
                skip=true
                break
            fi
        done
        
        if [ "$skip" = true ]; then
            print_info "  ⊘ Skipped Cursor-specific: $rule_name"
            continue
        fi
        
        # Prefer .mdc over .md if both exist
        if [[ "$rule_name" == *.md ]] && [ -f "$RULES_DIR/${base_name}.mdc" ]; then
            continue
        fi
        
        # Always output as .md for Claude Code
        target_name="${base_name}.md"
        target_file=".claude/rules/$target_name"
        
        adapt_mdc_for_claude "$rule_file" "$rule_file" > "$target_file"
        print_info "  ✓ Adapted $rule_name → $target_name"
        RULES_COPIED=$((RULES_COPIED + 1))
    fi
done

print_info "Adapted $RULES_COPIED foundation rule(s)"

# Process foundation commands → skills
print_info "Processing foundation commands → skills..."
SKILLS_COPIED=0

# High-value commands to convert to skills
SKILL_COMMANDS=("create_release" "fix_feature_bug" "create_feature_unit" "setup_symlinks" "pull" "commit")

for cmd_file in "$COMMANDS_DIR"/*.md; do
    if [ -f "$cmd_file" ]; then
        cmd_name=$(basename "$cmd_file" .md)
        
        # Check if this is a high-value command
        convert_to_skill=false
        for skill_cmd in "${SKILL_COMMANDS[@]}"; do
            if [[ "$cmd_name" == "$skill_cmd" ]]; then
                convert_to_skill=true
                break
            fi
        done
        
        if [ "$convert_to_skill" = true ]; then
            target_file=".claude/skills/${cmd_name}.md"
            adapt_command_to_skill "$cmd_file" "$cmd_file" "$cmd_name" > "$target_file"
            print_info "  ✓ Adapted $cmd_name.md → skill"
            SKILLS_COPIED=$((SKILLS_COPIED + 1))
        else
            print_info "  ⊘ Skipped command (low-priority): $cmd_name.md"
        fi
    fi
done

print_info "Adapted $SKILLS_COPIED foundation command(s) to skills"

# Process repository rules from docs/
print_info "Processing repository rules from docs/..."
REPO_RULES_COPIED=0

if [ -d "docs" ]; then
    while IFS= read -r -d '' rule_file; do
        rel_path="${rule_file#docs/}"
        base_name=$(basename "$rule_file")
        base_name_no_ext="${base_name%.*}"
        
        # Convert to .md for Claude
        target_name="${base_name_no_ext}.md"
        target_file=".claude/rules/$target_name"
        
        # Skip if Cursor-specific
        skip=false
        for skip_pattern in "${SKIP_RULES[@]}"; do
            if [[ "$base_name_no_ext" == *"$skip_pattern"* ]]; then
                skip=true
                break
            fi
        done
        
        if [ "$skip" = true ]; then
            print_info "  ⊘ Skipped Cursor-specific: $base_name"
            continue
        fi
        
        adapt_mdc_for_claude "$rule_file" "$rule_file" > "$target_file"
        print_info "  ✓ Adapted $base_name → $target_name"
        REPO_RULES_COPIED=$((REPO_RULES_COPIED + 1))
    done < <(find docs -name "*_rules.mdc" -o -name "*_rules.md" | sort | tr '\n' '\0')
fi

print_info "Adapted $REPO_RULES_COPIED repository rule(s)"

# Condense index_rules.md if over 40k chars (Claude Code performance limit)
INDEX_RULES=".claude/rules/index_rules.md"
if [ -f "$INDEX_RULES" ] && [ "$(wc -c < "$INDEX_RULES")" -gt 40000 ]; then
    print_info "Condensing index_rules.md (over 40k chars) for Claude Code performance..."
    awk '
        /^## 2\. Documentation Categories and Structure$/ { in_section2=1; print; print ""; print "See docs/context/index_rules.mdc Section 2 (document categories and tables) and Section 3 (dependency graph) for the full index."; print ""; print "---"; print ""; next }
        in_section2 && /^## 4\. Reading Strategies by Change Type$/ { in_section2=0; print; next }
        in_section2 { next }
        /^```mermaid$/ { in_mermaid=1; print "See docs/context/index_rules.mdc for the full dependency graph."; next }
        in_mermaid && /^```$/ { in_mermaid=0; next }
        !in_mermaid { print }
    ' "$INDEX_RULES" > "${INDEX_RULES}.tmp" && mv "${INDEX_RULES}.tmp" "$INDEX_RULES"
    print_info "  ✓ Condensed index_rules.md ($(wc -c < "$INDEX_RULES") chars)"
fi

# Generate CLAUDE.md from index_rules and agent_instructions
print_info "Generating CLAUDE.md..."

cat > .claude/CLAUDE.md << 'EOF'
# Neotoma Project Instructions for Claude Code

<!-- Generated from docs/context/index_rules.mdc and docs/foundation/agent_instructions_rules.mdc -->
<!-- Source: scripts/setup_claude_instructions.sh -->

## Document Loading Order (MANDATORY)

**Every session MUST begin by loading these documents in this order:**

1. **`docs/context/index_rules.mdc`** — Primary entrypoint; complete documentation map, reading strategies, dependency graph
2. **Foundation documents** from `docs/foundation/` in this order:
   - `core_identity.md` — What Neotoma is and is not (Truth Layer scope)
   - `philosophy.md` — Core principles and architectural invariants
   - `layered_architecture.md` — Truth Layer, Strategy Layer, Execution Layer
   - `product_principles.md` — Product design principles
   - `agent_instructions_rules.mdc` — Repository-wide agent instructions and validation checklist
3. **Task-specific docs** as indicated by the index (e.g. subsystems, architecture, testing)

**Why this order:** Foundation establishes constraints (determinism, immutability, Truth Layer boundaries) that all work must respect.

## Core Constraints (Summary)

Full constraints in `docs/foundation/agent_instructions_rules.mdc` and `.claude/rules/`. Summary:

**MUST enforce:**
- **Truth Layer boundaries**: No strategy/execution logic in Neotoma
- **Determinism**: No random IDs, no unstable sorting, hash-based entity/event IDs
- **Immutability**: Observations and source are immutable (reinterpretation creates NEW observations)
- **Schema-first**: Use application types from `docs/subsystems/record_types.md`
- **Explicit control**: User approves all ingestion; no background scanning
- **Provenance**: All outputs trace to source + config + timestamp
- **Graph integrity**: No orphans, no cycles, transactional writes
- **Privacy**: No PII in logs (IDs only)

**MUST NOT:**
- Violate architectural boundaries (no cross-layer logic)
- Introduce nondeterminism (no `Math.random()`, `Date.now()` in business logic, unstable iteration)
- Generate features outside MVP scope (no semantic search, no autonomous agents)
- Break immutability (no modifying observations/source after creation)
- Store docs in repo root (all docs in `docs/` subdirectories)

**Validation checklist** in `docs/foundation/agent_instructions_rules.mdc`.

## Configuration

- **`foundation-config.yaml`** — Repository-specific settings (conventions, security, workflows)
- **Environment variables** — See `docs/developer/env_check_rules.mdc`; check `.env.example` for required vars

## Autonomous Execution

**Proceed without asking for:**
- Routine implementation, refactors, tests, docs, lint fixes
- Anything where docs/codebase give a clear answer
- Edits or commands allowed by permissions (no confirmation needed)

**Stop and ask the user only when:**
1. There is an **unclear architectural or design choice** (e.g. where to put a module, which abstraction, how to cross subsystem boundaries)
2. **Getting it wrong would likely cause substantively wrong assumptions** (e.g. wrong layer, wrong consistency model, violating Truth Layer)

In those cases: ask a short, concrete question with 1–2 options or "proceed with X unless you prefer Y."

**Do not ask** for: "should I do X?" when X is already specified; "is this correct?" for obvious fixes; permission to use allowed tools.

**Alignment**: Mirrors risk management hold points (schema changes, foundation doc changes, security, constraint violations); ask when ambiguity could lead to high-risk wrong choice.

## Quick Reference

- **Architecture**: `docs/architecture/architecture.md`, `determinism.md`, `consistency.md`
- **Subsystems**: `docs/subsystems/` (schema, ingestion, reducer, relationships, search, auth, etc.)
- **Testing**: `docs/testing/testing_standard.md`, `automated_test_catalog.md`
- **Feature Units**: `docs/feature_units/standards/` (spec, manifest, execution)
- **Code conventions**: `docs/conventions/code_conventions.md` (TypeScript, SQL, YAML, Shell)
- **Documentation standards**: `docs/conventions/documentation_standards.md`

## Additional Instructions

All rules in `.claude/rules/` apply; they are modular instructions loaded automatically by context.

Skills in `.claude/skills/` are workflows invokable with `/skill-name` (e.g. `/create_release`, `/fix_feature_bug`).

For complete documentation map, reading strategies, and dependency graph, see `docs/context/index_rules.mdc`.
EOF

print_info "✓ Generated .claude/CLAUDE.md"

# Generate minimal settings.json (permissions live in ~/.claude/settings.json)
print_info "Generating .claude/settings.json..."

cat > .claude/settings.json << EOF
{
  "\$schema": "https://json.schemastore.org/claude-code-settings.json",
  "env": {},
  "hooks": {}
}
EOF

print_info "✓ Generated .claude/settings.json (permissions: use ~/.claude/settings.json)"

# Create .gitignore for .claude if it doesn't exist
if [ ! -f ".claude/.gitignore" ]; then
    cat > .claude/.gitignore << 'EOF'
# Local overrides (not committed)
settings.local.json
*.local.json
*.local.md

# User-specific state
.cache/
EOF
    print_info "✓ Created .claude/.gitignore"
fi

# Summary
print_info ""
print_info "════════════════════════════════════════"
print_info "Claude Code instructions setup complete!"
print_info "════════════════════════════════════════"
print_info ""
print_info "Generated files:"
print_info "  - .claude/CLAUDE.md (entrypoint)"
print_info "  - .claude/settings.json (minimal; permissions in ~/.claude/settings.json)"
print_info "  - .claude/rules/ ($RULES_COPIED rules)"
print_info "  - .claude/skills/ ($SKILLS_COPIED skills)"
print_info ""
print_info "Next steps:"
print_info "  1. Configure permissions in ~/.claude/settings.json if needed"
print_info "  2. Open Claude Code in this project"
print_info "  3. Claude will load CLAUDE.md and rules automatically"
print_info "  4. Use skills like /create_release, /fix_feature_bug"
print_info ""
print_info "To update after editing sources: ./scripts/setup_claude_instructions.sh"
print_info ""
