---
description: "Repository-wide instructions for AI assistants (Cursor, ChatGPT, Claude) working on Neotoma"
globs: ["**/*"]
alwaysApply: true
---

# ⚠️  DO NOT EDIT THIS FILE DIRECTLY
#
# This is a copy of: docs/foundation/agent_instructions_rules.mdc
# Source of truth: docs/foundation/agent_instructions_rules.mdc
#
# To edit this rule:
# 1. Edit the source file: docs/foundation/agent_instructions_rules.mdc
# 2. Run '/setup_cursor_copies' to sync changes
#
# This file will be overwritten when running setup_cursor_copies.


# Neotoma Agent Instructions

_(Repository-Wide Instructions for AI Assistants)_

---

## Purpose

This document provides repository-wide instructions for AI assistants (Cursor, ChatGPT, Claude) working on Neotoma.

---

## 23. Repository-Wide Agent Instructions

Every AI assistant (Cursor, ChatGPT, Claude) working on Neotoma MUST follow:

### 23.1 Mandatory Loading Order

1. **Load foundation documents from `docs/foundation/` FIRST** (see Section 23.1)
2. Load foundation documents from `docs/foundation/` (see Section 23.1)
3. **Load shared foundation processes from `foundation/` submodule** when needed:
   - `foundation/development/workflow.md` - For git workflow, branching, PRs
   - `foundation/conventions/code-conventions.md` - For code style and naming
   - `foundation/conventions/documentation-standards.md` - For documentation structure
   - `foundation/security/security-rules.md` - For security practices
   - `foundation-config.yaml` - For Neotoma-specific configuration
4. Load task-specific docs based on change type (see Section 23.3)
5. Load `docs/conventions/documentation_standards_rules.md` if creating/editing docs

### 23.2 Absolute Constraints

1. **Never violate Truth Layer boundaries** (no strategy/execution logic)
2. **Never introduce nondeterminism in core components** (no random IDs for entities/events, no unstable logic)
3. **Never generate features outside MVP scope** (no semantic search, no agents)
4. **Always follow schema-first principles** (type-driven, not inference-driven)
5. **Enforce immutability** (observations, source; reinterpretation creates NEW observations)
6. **Enforce safety and explicit control** (user approves all ingestion)
7. **Always output deterministic, validated artifacts** (code, specs, docs)
8. **Lead with defensible differentiators** (privacy-first, idempotent extraction with auditability, cross-platform) when positioning features or creating marketing content
9. **Use AI interpretation for unstructured files** with full auditability (interpretation config logged) and system-level idempotence (canonicalization + hashing)

### 23.2.1 Defensible Differentiation Constraints

**CRITICAL:** All release planning, marketing content, and feature positioning MUST validate defensible differentiation.

**When creating release plans:**

1. **Explicitly validate defensible differentiators** — Release must validate privacy-first, deterministic, and/or cross-platform differentiation
2. **Avoid feature-only releases** — Don't ship features without validating defensible differentiators
3. **Include acceptance criteria** — Release acceptance criteria must validate defensible differentiators
4. **Reference framework** — Link to [`docs/private/competitive/defensible_differentiation_framework.md`](../private/competitive/defensible_differentiation_framework.md) in release plans

**When creating marketing content:**

1. **Lead with defensible differentiators** (privacy-first, deterministic, cross-platform), not features alone
2. **Contextualize features** (entity resolution, timelines) as enabled by defensible differentiators
3. **Avoid feature-only positioning** (competitors developing similar features)
4. **Emphasize structural barriers** that prevent competitors from pursuing same path
5. **Validate messaging** — All marketing messaging must emphasize defensible differentiators first

**When creating content, documentation, or positioning:**

1. **Lead with defensible differentiators** (privacy-first, deterministic, cross-platform), not features alone
2. **Contextualize features** (entity resolution, timelines) as enabled by defensible differentiators
3. **Avoid feature-only positioning** (competitors developing similar features)
4. **Emphasize structural barriers** that prevent competitors from pursuing same path
5. **Reference framework** when appropriate: [`docs/private/competitive/defensible_differentiation_framework.md`](../private/competitive/defensible_differentiation_framework.md)

**Why:** Competitors (model providers, startups) are developing similar features (structured memory, entity resolution, timelines). Neotoma's defensible differentiators (privacy-first, deterministic, cross-platform) are what competitors cannot pursue due to structural constraints (business model conflicts, architectural constraints, platform lock-in revenue models).

### 23.3 Document Generation Rules

When generating docs, specs, or Feature Units:

1. **Treat foundation documents in `docs/foundation/` as root context** (resolve ambiguities here)
2. **Follow shared foundation documentation standards** from `foundation/conventions/documentation-standards.md`:
   - Required document structure (Purpose, Scope, Agent Instructions)
   - Writing style (no AI-generated patterns, RFC 2119 language)
   - Mermaid diagram standards
   - Example formatting requirements
3. **Reject scope creep** (stay within Truth Layer)
4. **Validate against invariants** (MUST/MUST NOT lists)
5. **Apply constraints to all artifacts** (specs, code, tests)
6. **Treat forbidden patterns as errors** (halt and report)

### 23.4 Code Generation Rules

When writing code:

1. **Follow shared foundation code conventions** from `foundation/conventions/code-conventions.md`:
   - File naming: `snake_case.ts` (except React components: `PascalCase.tsx`)
   - Function naming: `camelCase`
   - Type/interface naming: `PascalCase`
   - String quotes: double quotes (`"`)
   - Import order: external → internal → relative
   - See `foundation-config.yaml` for Neotoma-specific overrides
2. **Extraction approach:**
   - **AI interpretation for unstructured files** (PDFs, images) via interpretation service (auditable, idempotent)
   - **Rule-based extraction for structured data** (regex, parsing; deterministic)
3. **IDs MUST be hash-based** (entities, events, records)
4. **All collections MUST be sorted** (deterministic iteration)
5. **Graph writes MUST be transactional** (all-or-nothing)
6. **Errors MUST use ErrorEnvelope** (structured, trace_id)

### 23.5 Release Build Completion Rules

After completing a release build:

1. **MUST generate release report** with Section 9 (Testing Guidance)
2. **MUST include all manual test cases** from `integration_tests.md`
3. **MUST format test cases as user-facing instructions** (not developer commands)
4. **MUST present test cases to user** after build completion
5. **MUST reference Section 9** when presenting completion summary

See `.cursor/rules/post_build_testing.md` for complete requirements.

### 23.6 README Maintenance Rules

When documentation is created, modified, or deleted:

1. **MUST update README.md** to reflect changes
2. **MUST verify all links** in README are functional
3. **MUST ensure README accuracy** matches current documentation
4. **MUST maintain README completeness** as repository overview

See `.cursor/rules/readme_maintenance.md` for complete requirements.

### 23.7 Downstream Documentation Update Rules

When upstream documentation is updated:

1. **MUST identify downstream dependencies** that reference or depend on upstream changes
2. **MUST update all downstream docs** that restate or depend on upstream information
3. **MUST verify consistency** across the documentation tree
4. **MUST NOT leave contradictions** between upstream and downstream docs

**Common dependencies:**

- Foundation docs → Architecture, specs, subsystems, feature units, releases, README
- Architecture docs → Subsystems, feature units, releases, developer docs, README
- Specs → Feature units, releases, developer docs, README
- Standards → Feature units, releases, README
- Subsystems → Feature units, releases, developer docs, integrations, README

See `.cursor/rules/downstream_doc_updates.md` for complete requirements.

### 23.8 Documentation Location Rules

When creating or moving documentation:

1. **MUST NOT store documentation in repo root** — All documentation files MUST be placed in appropriate subdirectories under `docs/`
2. **Summary files, review files, implementation notes** — MUST be placed in relevant `docs/` subdirectories (e.g., `docs/conventions/`, `docs/developer/`, `docs/architecture/`)
3. **Only configuration and essential project files** belong in repo root (e.g., `package.json`, `tsconfig.json`, `README.md`, `LICENSE`)
4. **When moving files from root to docs/**, agents MUST:
   - Identify appropriate subdirectory based on content type
   - Move file to correct location
   - Update any references to the file location
   - Delete original file from root

See `.cursor/rules/instruction_documentation.md` for complete documentation location guidance.

### 23.9 Permanent Instruction Documentation Rules

When user provides instructions during conversation (especially "always" or "never" statements):

1. **MUST document immediately** — All "always" and "never" instructions MUST be documented in repository files during the same conversation
2. **MUST NOT defer** — Documentation MUST happen before proceeding with other work, not in a future conversation
3. **MUST use repo files** — Instructions MUST be written to appropriate documentation files (not just conversation memory)
4. **MUST classify and place correctly** — Determine appropriate location (agent_instructions.md, conventions/, architecture/, etc.)
5. **MUST make discoverable** — Ensure instruction is available to all agents via appropriate documentation or rule files

**Examples of instructions requiring immediate documentation:**

- "always do X" or "never do Y"
- "remember to" or "make sure to"
- "all agents should" or "everyone must"
- Any persistent behavioral constraint or policy

See `.cursor/rules/instruction_documentation.md` for complete workflow and requirements.

---

## 24. Risk Classification and Hold Points

### 24.1 When Agents MUST Stop

AI assistants MUST stop and request human approval for:

1. **Schema changes** (table structure, breaking JSONB changes)
2. **High-risk changes** (see `docs/private/governance/risk_classification.md`)
3. **Foundation document changes** (files in `docs/foundation/`)
4. **Security changes** (auth, RLS, encryption)
5. **Violating documented constraints** (even if user requests)

### 24.2 Risk Levels

**Low Risk:**

- Documentation updates
- UI text changes
- Unit test additions

**Medium Risk:**

- New Feature Units
- API endpoint additions
- Extraction logic changes

**High Risk:**

- Schema migrations
- Auth changes
- Breaking API changes

---

## 25. Final Invariants and Success Criteria

Neotoma MUST:

- **Preserve truth** (immutable, provenance-tracked)
- **Maintain determinism** (reproducible outputs)
- **Maintain stability** (no breaking changes)
- **Never infer meaning** (extract, don't interpret)
- **Never hallucinate** (no synthetic data)
- **Never mutate truth** (except metadata)
- **Never exceed its layer** (Truth only, no strategy/execution)

Neotoma MUST remain forever compatible with:

- **Agent-driven upper layers** (e.g., Strategy Layer with Agentic Portfolio as example, Execution Layer with Agentic Wallet as part)
- **AI-native operating environments** (MCP, agents)
- **Deterministic computational reasoning** (reproducible, testable)

Any layer built on Neotoma must respect the read-only boundary: it can consume truth but cannot mutate it except through the Domain Event → Reducer → State update flow.

---

## 26. How to Use This Document

### 26.1 For AI Assistants

**Every session:**

1. Load foundation documents from `docs/foundation/` first (see Section 23.1)
2. Load foundation documents from `docs/foundation/`
3. Reference foundation documents to resolve ambiguities
4. Validate all outputs against invariants
5. Stop at hold points for human approval

**When uncertain:**

- Default to conservative interpretation
- Prioritize determinism over convenience
- Prioritize correctness over feature richness
- Ask for clarification rather than guess

### 26.2 For Human Developers

**Before starting work:**

1. Read foundation documents from `docs/foundation/` (see Section 23.1)
2. Read foundation documents from `docs/foundation/`
3. Read relevant subsystem docs as indicated by context index
4. Understand which layer you're working in (Truth only)
5. Verify feature fits within Neotoma's scope

**During implementation:**

- Follow schema-first approach
- Write deterministic code
- Test for reproducibility
- Document all assumptions

**Before committing:**

- **Run security audit** from `foundation/security/pre-commit-audit.sh` (prevents committing secrets, protected files)
- Verify alignment with manifest
- Check MUST/MUST NOT lists
- Run full test suite
- Update docs if patterns changed
- **Follow foundation commit format** from `foundation/development/workflow.md`: `FU-{id}: {description}`

---

## Constraints Agents Must Enforce

1. **Truth Layer boundaries:** MUST NOT implement strategy, execution, or agent logic in Neotoma code
2. **Determinism:** MUST NOT introduce randomness, LLM extraction (MVP), or nondeterministic logic (no `Date.now()` in business logic, no random IDs, no unstable sorting)
3. **Immutability:** MUST NOT modify `raw_text`, `schema_type`, or `extracted_fields` after storage (only metadata mutable)
4. **Schema-first:** MUST use application types from `docs/subsystems/record_types.md` (e.g., `invoice`, `receipt`), NOT schema families (e.g., `Financial`, `Productivity`)
5. **Explicit control:** MUST NOT implement automatic ingestion, background scanning, or implicit data collection
6. **Provenance:** MUST trace all outputs to source file + extraction rule + timestamp
7. **Graph integrity:** MUST maintain zero orphans, no cycles, typed edges only, transactional writes
8. **Privacy:** MUST NOT log PII from `properties` (record IDs only, not extracted fields)
9. **Multi-pattern matching:** MUST use 2+ patterns for schema detection (see `record_types.md`)
10. **Consistency models:** MUST apply correct consistency tier per subsystem (strong vs bounded eventual)
11. **Security:** MUST NOT include credentials (API keys, tokens, service keys) in agent instructions, conversation text, or commit messages. Credentials MUST be injected via secure mechanisms (e.g., Cursor Cloud Agents Secrets) and agents MUST verify their availability via environment variable checks, not export commands with credential values

### Forbidden Patterns

- Violating Truth Layer boundaries (implementing strategy, execution, or autonomous agent behavior in Neotoma)
- Introducing nondeterminism in core components (random entity/event IDs, unstable sorting, `Date.now()` in entity ID generation)
- Bypassing interpretation service for unstructured files (must use interpretation service with audit trail)
- Claiming replay determinism for AI interpretation (auditable but not replay-deterministic)
- Generating features outside MVP scope (semantic search, real-time collaboration, predictive analytics)
- Breaking immutability (modifying observations or source after creation; reinterpretation creates NEW observations)
- Inferring beyond extraction (creating entities not present in fields, inferring relationships without source)
- Using schema families as database types (code must use application types: `invoice` not `Financial`)
- Schema mutations (changing assigned schema_type after creation)
- Synthetic data beyond interpretation (guessing missing information, hallucinating fields)
- Upward dependencies (Domain layer calling Application or Presentation layers)
- Non-transactional graph writes (all source+observation+entity inserts must be atomic)
- Not logging interpretation config (model, temperature, prompt_hash must be logged for audit trail)
- Including credentials in agent instructions (no API keys, tokens, or service keys in prompt text, conversation messages, or code comments; use secure injection mechanisms like Cursor Secrets)
- Storing documentation files in repo root (all documentation MUST be in appropriate `docs/` subdirectories)

### Validation Checklist

- [ ] Change respects Truth Layer boundaries (no strategy/execution logic)
- [ ] No nondeterminism in core components (no random entity/event IDs, no unstable sorts)
- [ ] AI interpretation uses interpretation service with audit trail (config logged)
- [ ] System-level idempotence enforced (canonicalization + hashing)
- [ ] Immutability preserved (observations, source; reinterpretation creates NEW observations)
- [ ] Schema changes are additive only (no breaking changes, no column removal)
- [ ] Uses application types from `record_types.md` (not schema families)
- [ ] Multi-pattern matching for schema detection (2+ patterns required)
- [ ] Graph integrity maintained (no orphans, no cycles, transactional writes)
- [ ] Privacy preserved (no PII in logs, only record IDs)
- [ ] Provenance maintained (all outputs trace to source + interpretation run)
- [ ] Consistency model correct (strong vs bounded eventual per subsystem)
- [ ] Security: No credentials included in agent instructions, conversation text, or code (use secure injection mechanisms)
- [ ] Documentation location: No documentation files stored in repo root (all docs in `docs/` subdirectories)
- [ ] Tests cover all new paths (unit, integration, E2E as appropriate)
- [ ] Documentation updated to reflect changes
- [ ] Downstream documentation updated if upstream docs changed
- [ ] README.md updated if documentation changes affect user-facing information
- [ ] Feature fits within Neotoma scope (Truth Layer only)
- [ ] No violations of MUST/MUST NOT lists

---

## Related Documents

- [`docs/foundation/philosophy.md`](./philosophy.md) — Core philosophy and architectural invariants
- [`docs/foundation/layered_architecture.md`](./layered_architecture.md) — Layered architecture
- [`docs/conventions/documentation_standards.md`](../conventions/documentation_standards.md) — Documentation standards

## Using Foundation Submodule

Neotoma uses the shared **foundation** submodule (`foundation/`) for development processes and conventions:

### When to Reference Foundation

**Development Workflow:**

- Creating branches: See `foundation/development/workflow.md` and `foundation/development/branch-strategy.md`
- Creating worktrees: Use `foundation/development/worktree-setup.sh`
- PR process: Follow `foundation/development/pr-process.md`
- Commit format: `FU-{id}: {description}` (configured in `foundation-config.yaml`)

**Code Conventions:**

- Code style: See `foundation/conventions/code-conventions.md`
- Naming patterns: See `foundation/conventions/naming-patterns.yaml`
- Neotoma overrides: Check `foundation-config.yaml` for repo-specific settings

**Documentation:**

- Doc structure: Follow `foundation/conventions/documentation-standards.md`
- Writing style: Avoid AI-generated patterns, use RFC 2119 language
- Agent Instructions: Use template from `foundation/agent_instructions/README.md`

**Security:**

- Pre-commit audit: Run `foundation/security/pre-commit-audit.sh` before commits
- Credential management: See `foundation/security/credential-management.md`
- Security rules: See `foundation/security/security-rules.md`

**Configuration:**

- Neotoma config: `foundation-config.yaml` (repo root)
- Foundation defaults: `foundation/config/foundation-config.yaml`

### Foundation vs Neotoma Foundation Docs

- **`foundation/` submodule**: Shared development processes (workflow, conventions, security) - can be used by other repos
- **`docs/foundation/`**: Neotoma-specific foundation (philosophy, architecture, product positioning) - Neotoma only

Both are important:

- Use `foundation/` for development practices (how to code, commit, review)
- Use `docs/foundation/` for Neotoma architecture (what to build, why, constraints)

### Syncing Foundation Updates

When foundation submodule is updated:

```bash
# Update to latest foundation
git submodule update --remote foundation

# Or use sync script
./foundation/scripts/sync-foundation.sh
```

See `foundation/README.md` for complete foundation documentation.

### Foundation Pull Workflow

**MANDATORY:** When pulling foundation submodule (via `/pull foundation` command), agents MUST:

1. Complete the pull workflow (commit local changes, fetch, pull)
2. **ALWAYS run `/setup_symlinks` command** after successful foundation pull
3. This ensures cursor rules and commands symlinks are updated with latest foundation changes

**Why:** Foundation updates may include new or modified cursor rules/commands. Running `/setup_symlinks` ensures these changes are immediately available in the repository.

See `.cursor/commands/pull.md` for complete pull workflow documentation.
