# Integration Test Quality Rules

**Reference**: `foundation/conventions/testing_conventions.md` — Generic testing principles

This document applies foundation testing conventions to Neotoma-specific integration tests.

## Purpose

Ensures Neotoma integration tests catch real bugs by applying foundation testing principles to Neotoma's database schema, workflows, and patterns.

## Scope

This document covers:
- Applying foundation principles to Neotoma (Supabase, auto-enhancement, etc.)
- Neotoma-specific edge cases (default UUID, fragment_type, entity_type)
- Neotoma-specific examples and patterns

This document does NOT cover:
- Generic testing principles (see `foundation/conventions/testing_conventions.md`)
- Unit test patterns (see `testing_standard.md`)
- E2E test patterns (see `testing_standard.md`)
- Fixture standards (see `fixtures_standard.md`)

## Trigger Patterns

Apply these rules when:
- Writing integration tests for database operations
- Testing services that interact with Supabase/PostgreSQL
- Testing workflows with async processing or queues
- Testing user_id scoping or multi-tenancy
- Testing foreign key constraints or database schema

## Foundation Principles Applied to Neotoma

**See `foundation/conventions/testing_conventions.md` for generic principles.**

This section shows how to apply those principles to Neotoma-specific code.

### 1. Don't Mock Supabase in Integration Tests

**Foundation principle**: Use real dependencies in integration tests.

**Neotoma application**: Don't mock `supabase.from()` or Supabase query builders.

**Neotoma example - what NOT to do:**
```typescript
// ❌ Mocking Supabase hides query bugs
it("should find raw fragments", async () => {
  vi.spyOn(supabase, "from").mockReturnValue({
    select: vi.fn().mockResolvedValue({ 
      data: [{ fragment_type: "task", fragment_key: "field1" }] 
    })
  });
  
  const fragments = await service.getFragments("task");
  expect(fragments.length).toBe(1);
});
```

**Neotoma example - correct approach:**
```typescript
// ✅ Real Supabase operations catch query bugs
it("should find raw fragments", async () => {
  // Seed test data
  await supabase.from("raw_fragments").insert({
    fragment_type: "task",
    fragment_key: "field1",
    fragment_value: "test",
    user_id: null,
  });
  
  // Test actual Supabase query
  const fragments = await service.getFragments("task");
  expect(fragments.length).toBe(1);
  expect(fragments[0].fragment_key).toBe("field1");
  
  // Verify database state
  const { data } = await supabase
    .from("raw_fragments")
    .select("*")
    .eq("fragment_type", "task");
  expect(data?.length).toBe(1);
});
```

**Why this matters for Neotoma**: Recent bugs (wrong column names, incorrect null handling) were hidden by mocked database queries. Real operations would have caught them.

### 2. Use Strong Assertions for Neotoma Workflows

**Foundation principle**: Verify correct outcomes, not just absence of errors.

**Neotoma application**: Verify auto-enhancement workflows succeeded, not just completed.

**❌ Weak assertions that allowed bugs:**
```typescript
// From actual Neotoma test - passes even if all items skipped due to bugs
const processResult = await processAutoEnhancementQueue();
expect(processResult.processed + processResult.skipped).toBeGreaterThan(0);
```

**✅ Strong assertions that catch bugs:**
```typescript
// Requires actual success
const processResult = await processAutoEnhancementQueue();
expect(processResult.succeeded).toBeGreaterThan(0);
expect(processResult.failed).toBe(0);

// Verify schema recommendations were created
const { data: recommendations, error } = await supabase
  .from("schema_recommendations")
  .select("*")
  .eq("entity_type", testEntityType);

expect(error).toBeNull();
expect(recommendations?.length).toBeGreaterThan(0);
expect(recommendations![0].status).toBe("auto_applied");

// Verify queue items were processed
const { data: queueItems } = await supabase
  .from("auto_enhancement_queue")
  .select("*")
  .eq("entity_type", testEntityType)
  .eq("status", "completed");

expect(queueItems?.length).toBeGreaterThan(0);
```

### 3. Test Neotoma User ID Edge Cases

**Foundation principle**: Test null, default values, and boundary conditions.

**Neotoma application**: Test Neotoma's default UUID and null user_id handling.

**Neotoma-specific edge cases:**
1. `user_id: null` (global/system data)
2. `user_id: "00000000-0000-0000-0000-000000000000"` (Neotoma's default user)
3. `user_id: "<actual-uuid>"` (real user)
4. Queries using `.or()` to match both null and default UUID

**Neotoma examples:**
```typescript
describe("user_id handling", () => {
  it("should handle null user_id", async () => {
    await supabase.from("raw_fragments").insert({
      fragment_type: "task",
      fragment_key: "test_field",
      user_id: null,
      ...
    });
    
    // Verify query finds it
    const { data } = await supabase
      .from("raw_fragments")
      .select("*")
      .eq("fragment_type", "task")
      .is("user_id", null);
    
    expect(data?.length).toBe(1);
  });
  
  it("should handle default UUID", async () => {
    const defaultUserId = "00000000-0000-0000-0000-000000000000";
    await supabase.from("raw_fragments").insert({
      fragment_type: "task",
      fragment_key: "test_field",
      user_id: defaultUserId,
      ...
    });
    
    // Verify query finds it
    const { data } = await supabase
      .from("raw_fragments")
      .select("*")
      .eq("fragment_type", "task")
      .eq("user_id", defaultUserId);
    
    expect(data?.length).toBe(1);
  });
  
  it("should find data with both null and default UUID", async () => {
    // Insert with null
    await supabase.from("raw_fragments").insert({
      fragment_type: "task",
      fragment_key: "field1",
      user_id: null,
      ...
    });
    
    // Insert with default UUID
    const defaultUserId = "00000000-0000-0000-0000-000000000000";
    await supabase.from("raw_fragments").insert({
      fragment_type: "task",
      fragment_key: "field2",
      user_id: defaultUserId,
      ...
    });
    
    // Verify query finds both
    const { data } = await supabase
      .from("raw_fragments")
      .select("*")
      .eq("fragment_type", "task")
      .or(`user_id.is.null,user_id.eq.${defaultUserId}`);
    
    expect(data?.length).toBe(2);
  });
});
```

### 4. Test Foreign Key Constraints

**MUST test that foreign key relationships work correctly**

When a table has foreign key constraints, explicitly test:
1. Inserting with valid foreign key succeeds
2. Inserting with invalid foreign key fails
3. Inserting with `null` (if allowed) succeeds

**Example:**
```typescript
it("should allow queue items with null user_id", async () => {
  const { data, error } = await supabase
    .from("auto_enhancement_queue")
    .insert({
      entity_type: "task",
      fragment_key: "test_field",
      user_id: null, // Should succeed - no foreign key check for null
      status: "pending",
    })
    .select();
  
  expect(error).toBeNull();
  expect(data).toBeDefined();
  expect(data![0].user_id).toBeNull();
});

it("should reject queue items with non-existent user_id", async () => {
  const { error } = await supabase
    .from("auto_enhancement_queue")
    .insert({
      entity_type: "task",
      fragment_key: "test_field",
      user_id: "non-existent-uuid",
      status: "pending",
    });
  
  expect(error).toBeDefined();
  expect(error!.code).toBe("23503"); // Foreign key violation
});
```

### 5. Test Actual Database State

**MUST verify database state matches expectations**

Don't just check that operations completed; verify the data is correct in the database.

**❌ Weak verification:**
```typescript
// Only checks operation succeeded
const result = await service.storeEntity(data);
expect(result.success).toBe(true);
```

**✅ Strong verification:**
```typescript
// Verifies operation succeeded AND database state is correct
const result = await service.storeEntity(data);
expect(result.success).toBe(true);

// Verify actual database state
const { data: stored, error } = await supabase
  .from("entities")
  .select("*")
  .eq("id", result.entity_id)
  .single();

expect(error).toBeNull();
expect(stored).toBeDefined();
expect(stored!.canonical_name).toBe(data.expected_canonical_name);
expect(stored!.user_id).toBe(data.user_id);
```

### 6. Test Query Construction

**MUST test that queries work with actual database schema**

When testing services that query the database, verify:
1. Query uses correct column names
2. Query uses correct table names
3. Query handles null vs non-null correctly
4. Query returns expected results

**Example:**
```typescript
it("should query fragments with correct column names", async () => {
  // Insert test fragment
  await supabase.from("raw_fragments").insert({
    fragment_type: "task",
    fragment_key: "test_field",
    fragment_value: "test",
    user_id: null,
  });
  
  // Test query construction
  const service = new SchemaRecommendationService();
  const confidence = await service.calculateFieldConfidence({
    entity_type: "task",
    fragment_key: "test_field",
    user_id: null,
  });
  
  // Verify query succeeded and returned data
  expect(confidence.confidence).toBeGreaterThan(0);
  expect(confidence.inferred_type).toBe("string");
});
```

### 7. Avoid Silent Failures

**MUST test that errors are propagated correctly**

When functions catch errors and handle them internally, test both success and failure cases explicitly.

**❌ Silent failure not tested:**
```typescript
async function queueItem(data) {
  try {
    await supabase.from("queue").insert(data);
    // Silent success - no way to know if it worked
  } catch (error) {
    logger.error("Failed to queue", error);
    // Silent failure - caller doesn't know it failed
  }
}
```

**✅ Test both outcomes:**
```typescript
it("should successfully queue item with valid data", async () => {
  await service.queueItem(validData);
  
  // Verify it was actually queued
  const { data } = await supabase.from("queue").select("*");
  expect(data?.length).toBe(1);
});

it("should log error but not throw when queue creation fails", async () => {
  const spy = vi.spyOn(logger, "error");
  
  await service.queueItem(invalidData);
  
  // Verify error was logged
  expect(spy).toHaveBeenCalled();
  
  // Verify item was NOT queued
  const { data } = await supabase.from("queue").select("*");
  expect(data?.length).toBe(0);
});
```

### 8. Test Complete Workflows

**MUST test end-to-end workflows, not just individual steps**

Integration tests should verify entire workflows work correctly.

**Example:**
```typescript
it("should complete auto-enhancement workflow from storage to schema update", async () => {
  // 1. Seed minimal schema
  await seedTestSchema(server, "task", {
    title: { type: "string", required: false },
  });
  
  // 2. Store data with unknown fields
  const result = await server.store({
    user_id: testUserId,
    file_path: testFile,
    interpret: false,
  });
  
  const responseData = JSON.parse(result.content[0].text);
  expect(responseData.unknown_fields_count).toBeGreaterThan(0);
  
  // 3. Verify raw_fragments created
  const { data: fragments } = await supabase
    .from("raw_fragments")
    .select("*")
    .eq("fragment_type", "task");
  expect(fragments?.length).toBeGreaterThan(0);
  
  // 4. Verify queue items created
  const { data: queueItems } = await supabase
    .from("auto_enhancement_queue")
    .select("*")
    .eq("entity_type", "task");
  expect(queueItems?.length).toBeGreaterThan(0);
  expect(queueItems![0].status).toBe("pending");
  
  // 5. Process queue
  const processResult = await processAutoEnhancementQueue();
  expect(processResult.succeeded).toBeGreaterThan(0);
  expect(processResult.failed).toBe(0);
  
  // 6. Verify schema was updated
  const { data: schema } = await supabase
    .from("schema_registry")
    .select("schema_definition")
    .eq("entity_type", "task")
    .eq("active", true)
    .single();
  
  const fields = Object.keys(schema!.schema_definition.fields);
  expect(fields.length).toBeGreaterThan(1); // More than just title
});
```

## Checklist for Integration Tests

Before considering an integration test complete, verify:

- [ ] Test uses real database operations (no mocked Supabase queries)
- [ ] Test verifies database state after operations (not just return values)
- [ ] Assertions are strong (verify correct outcome, not just "no error")
- [ ] Edge cases tested (null, default UUID, empty, invalid)
- [ ] Foreign key constraints tested (if applicable)
- [ ] Error cases tested explicitly (not just happy path)
- [ ] Complete workflows tested end-to-end
- [ ] Test cleanup is thorough (no data leaks between tests)
- [ ] Test is deterministic (100 runs → 100 same results)

## Common Pitfalls

### Pitfall 1: Assuming Success
```typescript
// ❌ Assumes operation succeeded
const result = await service.doOperation();
expect(result).toBeDefined();

// ✅ Verifies operation succeeded AND state is correct
const result = await service.doOperation();
expect(result.success).toBe(true);

const { data, error } = await supabase.from("table").select("*");
expect(error).toBeNull();
expect(data?.length).toBe(1);
```

### Pitfall 2: Testing Mocked Behavior
```typescript
// ❌ Tests mock, not real code
vi.spyOn(service, "checkEligibility").mockResolvedValue({ eligible: true });
const result = await processor.process();
expect(result.succeeded).toBe(1);

// ✅ Tests real code with real database
await seedTestData();
const result = await processor.process();
const { data } = await supabase.from("queue").select("status");
expect(data![0].status).toBe("completed");
```

### Pitfall 3: Weak Assertions
```typescript
// ❌ Passes even if all items skipped
expect(result.processed + result.skipped).toBeGreaterThan(0);

// ✅ Verifies correct outcome
expect(result.succeeded).toBeGreaterThan(0);
expect(result.failed).toBe(0);
```

### Pitfall 4: Missing Edge Cases
```typescript
// ❌ Only tests happy path
it("should process items", async () => {
  const result = await process({ user_id: "test-user" });
  expect(result.success).toBe(true);
});

// ✅ Tests edge cases
describe("user_id handling", () => {
  it("should handle null user_id", async () => { ... });
  it("should handle default UUID", async () => { ... });
  it("should handle real user UUID", async () => { ... });
});
```

### Pitfall 5: Not Testing Foreign Keys
```typescript
// ❌ Doesn't verify foreign key works
it("should create queue item", async () => {
  const result = await service.queueItem({ user_id: testUserId });
  expect(result).toBeDefined();
});

// ✅ Verifies foreign key constraint
it("should allow null user_id", async () => {
  const { error } = await supabase.from("queue").insert({
    entity_type: "task",
    user_id: null,
  });
  expect(error).toBeNull();
});

it("should reject non-existent user_id", async () => {
  const { error } = await supabase.from("queue").insert({
    entity_type: "task",
    user_id: "non-existent-uuid",
  });
  expect(error).toBeDefined();
  expect(error!.code).toBe("23503"); // Foreign key violation
});
```

## Agent Instructions

### When to Load This Document

Load when:
- Writing integration tests for database operations
- Reviewing integration tests for quality
- Debugging why tests didn't catch bugs
- Planning test strategy for new features

### Required Co-Loaded Documents

- `docs/testing/testing_standard.md` — Base testing standards
- `docs/architecture/determinism.md` — Deterministic testing requirements
- `docs/testing/fixtures_standard.md` — Fixture guidelines

### Constraints Agents Must Enforce

1. **Minimize mocking** — Integration tests MUST use real database operations, not mocks
2. **Strong assertions** — Tests MUST verify correct outcomes, not just "no errors"
3. **Edge cases** — Tests MUST cover null, default UUID, and real UUID cases for user_id
4. **Foreign keys** — Tests MUST verify foreign key constraints work correctly
5. **Database state** — Tests MUST verify actual database state after operations
6. **Query construction** — Tests MUST verify queries use correct column/table names
7. **Error cases** — Tests MUST test both success and failure paths explicitly
8. **Complete workflows** — Tests MUST verify end-to-end workflows, not just individual steps

### Forbidden Patterns

- Mocking database queries in integration tests (except for external APIs)
- Using weak assertions like `processed + skipped > 0`
- Testing only happy paths without edge cases
- Not verifying database state after operations
- Assuming operations succeeded without checking
- Not testing foreign key constraints explicitly
- Skipping tests for error propagation

### Validation Checklist

Before marking integration test complete:

- [ ] Test uses real database (no mocked Supabase queries)
- [ ] Assertions verify correct outcome (not just "no error")
- [ ] Edge cases tested (null, default UUID, invalid)
- [ ] Foreign key constraints tested (if table has FK)
- [ ] Database state verified after operations
- [ ] Error cases tested explicitly
- [ ] Complete workflow tested end-to-end
- [ ] Test cleanup prevents data leaks
- [ ] Test is deterministic (repeatable)
- [ ] Test follows existing patterns in codebase

## Related Documents

- [`foundation/conventions/testing_conventions.md`](../../foundation/conventions/testing_conventions.md) — Generic testing principles
- [`docs/testing/testing_standard.md`](./testing_standard.md) — Neotoma testing standards
- [`docs/testing/test_quality_enforcement_rules.mdc`](./test_quality_enforcement_rules.mdc) — Enforceable patterns
- [`docs/architecture/determinism.md`](../architecture/determinism.md) — Deterministic testing requirements
- [`docs/testing/fixtures_standard.md`](./fixtures_standard.md) — Fixture guidelines
- [`docs/reports/AUTO_ENHANCEMENT_TEST_COVERAGE_GAPS.md`](../reports/AUTO_ENHANCEMENT_TEST_COVERAGE_GAPS.md) — Analysis of specific coverage gaps
