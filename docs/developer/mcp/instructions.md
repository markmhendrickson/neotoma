# MCP interaction instructions

## Scope

Instruction text the Neotoma MCP server sends to clients so agents know how to use MCP actions. The server loads this file at runtime; edits here take effect without code changes in `src/server.ts`. For user-facing docs see `docs/specs/MCP_SPEC.md` and `docs/developer/mcp_overview.md`.

## Instructions (content sent to clients)

The block below is loaded and sent to MCP clients as interaction instructions. One instruction per line.

```
Do not respond or use any other tool before completing the store call for this turn. Then follow the recipes below.
MANDATORY: Every turn—including when the user asks for a draft, advice, or a non-storage task—perform one store call (conversation + this user message) first; responding or calling other tools before that store is forbidden.
Before storing: run a bounded retrieval for entities implied by the message (retrieve_entity_by_identifier for names/emails/identifiers, retrieve_entities for related types e.g. task, invoice, contact). Use results when storing to link to or reuse existing records; skipping this retrieval before storing is forbidden.
Storage (chat, attachment, entity-extraction): Recipes below are self-contained. Do not list_dir, glob, or read_file MCP tool descriptor/schema files for these flows, all parameter names and response paths are here.
FIRST ACTIONS EVERY TURN: (1) Bounded retrieval for entities implied by the message (retrieve_entity_by_identifier for identifiers, retrieve_entities for related types). (2) One store call for the conversation and current user message (and any entities implied by the message, see unified recipe). If the user attached a file, store it in the same request when possible and link with EMBEDS (see Attachment turn recipe below). After (1) and (2), then respond or use other tools.
Chat, attachment, and entity-extraction: do NOT list, glob, or read MCP tool descriptor/schema files. Use only the recipe below, no exploration. Tool parameters: store(entities, idempotency_key, relationships, file_path|file_content+mime_type, file_idempotency_key?); create_relationship(relationship_type, source_entity_id, target_entity_id). Response IDs: combined store → structured.entities[].entity_id and unstructured.interpretation.entities[0].entityId (camelCase). Do not open schemas to verify.
Unified store (one call per turn): store_structured with entities = [ { entity_type: "conversation", title? }, { entity_type: "agent_message", role: "user", content: "<exact message>", turn_key: "{conversation_id}:{turn_id}" }, …optional extracted entities… ]. Always include relationship PART_OF from message (index 1) to conversation (index 0). If the message implies any entity (purchase, task, event, person, place, etc.), append one or more entities with a descriptive entity_type and whatever properties the message implies—no fixed schema; server accepts arbitrary fields. For each extracted entity (index 2, 3, …), add REFERS_TO from message (index 1) to that entity. Indices: 0=conversation, 1=message, 2+=extracted. Response: entities[0]=conversation id, [1]=message id, [2]=first extracted id, etc. idempotency_key: "conversation-{conversation_id}-{turn_id}-{suffix}" or "conversation-chat-<turn>-{suffix}". Do not call list_entity_types before storing; do not reason about schema—use descriptive entity_type and fields from the message.
Attachment turn (exact recipe; use response paths inline, do not open tool schemas): (1) one store call with entities [ { entity_type: "conversation", title? }, { entity_type: "agent_message", role: "user", content: "<exact message or 'Attached: <filename>'", turn_key: "{conversation_id}:{turn_id}" } ], idempotency_key "conversation-{conversation_id}-{turn_id}-{timestamp_ms}", relationships [ { relationship_type: "PART_OF", source_index: 1, target_index: 0 } ], and file_path: "<user attachment path>" (resolve to absolute when possible) or file_content+mime_type. Optional file_idempotency_key: "file-<short-slug>" (e.g. file-sample-receipt-pdf). (2) create_relationship with relationship_type: "EMBEDS", source_entity_id: step1_response.structured.entities[1].entity_id, target_entity_id: step1_response.unstructured.interpretation.entities[0].entityId. Do not read or interpret file contents, server interprets when interpret=true.
Screenshot/image: When the user provides a screenshot or image, extract structured data from the visible content (people, messages, dates, criteria, tasks, events, offers, transactions, etc.) and store it. Use the attachment turn recipe: store with entities [ conversation, message, …extracted entities ], file_path or file_content+mime_type for the image, relationships PART_OF (message→conversation), REFERS_TO (message→each extracted entity), EMBEDS (message→file entity). Extract every distinct entity visible in the image before responding.
If host provides no conversation_id/turn_id: use idempotency_key "conversation-chat-<turn>-<timestamp_ms>" and turn_key "chat:<turn>" (e.g. chat:attach-1).
Checklist each turn: (1) store per unified recipe (conversation + message + any extracted entities in one call) (2) if attachment: include file in the same store call, then create_relationship(EMBEDS, step1.structured.entities[1].entity_id, step1.unstructured.interpretation.entities[0].entityId) (3) then other actions and reply.
MANDATORY in chat: every turn persist conversation and user message (and any implied entities) in one store call per unified recipe. Do not skip for greetings or minimal messages. Same turn as your response. Responding to the user before storing this turn is forbidden.
Turn identity: Use host conversation_id/thread_id/session_id and turn_id when available. If the host does not provide them, use synthetic id (e.g. "cursor-chat") and turn index or timestamp; turn_key = "{conversation_id}:{turn_id}" or "chat:<turn>"; idempotency_key unique per turn (e.g. conversation-cursor-chat-1-<timestamp_ms> or conversation-cursor-chat-1-coffee).
Fallback if relationships not supported: (1) store_structured with entities and idempotency_key; (2) create_relationship(PART_OF, response.entities[1].entity_id, response.entities[0].entity_id). For extracted entities, create_relationship(REFERS_TO, response.entities[1].entity_id, response.entities[N].entity_id) for each.
create_relationship (only if not using one-call store): create_relationship(relationship_type, source_entity_id, target_entity_id). Use response.entities[N].entity_id from a prior store_structured; no tool schema read.
Chat details: Overwriting between branches is acceptable; users can view historical turns or branches via observation history (e.g. list_observations). Reverted turns: optionally create_relationship(SUPERSEDES, new_message_id, previous_message_id). Relationship types: PART_OF, REFERS_TO, EMBEDS, SUPERSEDES, etc. (see MCP spec).
Do not mention storage, memory, or linking unless the user asked. Do not describe internal persistence in thought or reply (e.g. "Persisting this turn, then replying", "Storing the conversation first"). When confirming something was stored, use memory-related language ("remember", "recall", "stored in memory") and include one of those phrases.
Use MCP actions proactively. Store when the user states relevant information; store first, then respond. Do not skip store because the user did not ask to save.
Other MCPs: When you pull data (email, calendar, search), extract and store people, companies, locations, events, tasks, notifications, device status, relationships. Create tasks for action items. Link events/tasks to locations. Do not respond with that data until storage is complete (same turn).
Result lists from other MCPs (for example Gmail search/list endpoints): before replying with the list, store the retrieved records in Neotoma in the same turn (store each record or a complete batch snapshot with all key fields). Replying with fetched list data before this storage is forbidden.
For list responses, do a completeness check before replying: ensure stored_count matches fetched_count for the requested result set (or explain truncation). If counts do not match, keep storing and do not return list contents yet.
User identity: When the user provides or implies their identity (name, email, "me"/"myself"), store as contact or person in the same turn when you have enough to identify.
Extract and store all relevant entities from the user: people, tasks, events, commitments, preferences, possessions, relationships, places. Store every distinct entity. Places: store as location/property/place and link to tasks or other entities. Implied relationships: use create_relationship or relationship fields per schema. Container+asset: EMBEDS with source=container, target=asset; if file in Neotoma then store file, create image/media entity, create_relationship(EMBEDS, container_id, asset_id); if asset elsewhere store only a reference on the container.
Tasks: Create a task when the user expresses intent, obligation, or future action ("I need to", "remind me", deadlines). Unless they say no reminders/tasks, create task with due date if available and relate to person or entity.
Entity types (schema-agnostic): For storage from chat, use a descriptive entity_type and whatever properties the message implies; server accepts arbitrary fields and infers schema. Do not call list_entity_types before storing. Examples of entity_type (not fixed shapes): transaction, task, event, person, contact, company, receipt, note, location, place. For other flows, list_entity_types with a keyword or store with a descriptive type.
Conventions: Avoid get_authenticated_user unless the next action needs it. Check for existing records before storing. Include all fields from source when storing. Structured path (entities) for conversation- or tool-sourced data; omit original_filename. Unstructured path (file_content+mime_type or file_path) for user attachments or files to preserve; pass raw file, do not interpret. Omit user_id (inferred). After MCP actions, summarize entities and relationships with snapshot fields. Do not repeat the same phrase as both thought and section heading. At session start, optionally call npm_check_update with packageName "neotoma" and the client version; if updateAvailable, prompt user to upgrade.
```

## One-call chat persistence

Optional `relationships` on `store_structured`: array of `{ relationship_type, source_index, target_index }` (indices into the request’s `entities` array). Server creates entities then relationships in one request. No separate `store_chat_turn` action; the generic store covers chat.

## Reducing agent exploration on storage turns

The instruction block is tuned so agents can do “conversation + message + store file + EMBEDS” without opening tool schemas or exploring the MCP tool set:

1. **No exploration** — A single, prominent line: "do NOT list, glob, or read MCP tool descriptor/schema files" for chat and attachment flow. Use only the recipe and quick reference.
2. **Inline response paths** — Step (3) and the checklist use literal paths (`step1.entities[1].entity_id`, `step2.interpretation.entities[0].entityId`) so the agent does not need to open schemas to find where IDs live.
3. **Unified store shape** — One recipe: entities = [conversation, message, …optional extracted entities]; always PART_OF(message→conversation), plus REFERS_TO(message→each extracted entity) when present. Reduces branching between chat-only and entity-extraction.
4. **Fallback ids** — One line gives a concrete fallback when the host provides no conversation_id/turn_id (`conversation-chat-<turn>-<timestamp_ms>`, `turn_key "chat:<turn>"`), so the agent does not re-derive the pattern.
5. **One recipe, one checklist** — Attachment steps, response paths, and file_path guidance are in one recipe; the checklist references it. Duplicate "user only attached" and separate "response IDs" lines were removed to cut parsing and branching.

Keeping the recipe in sync with server response shapes (e.g. `unstructured.interpretation.entities[0].entityId` camelCase) reduces overhead. Attachment turns now use one store request for structured and unstructured data, then one EMBEDS relationship call.

## Reducing agent work on entity-extraction turns

For turns where the user shares a fact that implies an entity (e.g. “I bought a $5 coffee at Starbucks today”), agents can otherwise do extra work: exploring tool schemas (glob/list/read of MCP descriptor files), multiple tool calls (store conversation+message, then store transaction, then create_relationship), and extra reasoning. The instruction block is tuned to avoid that:

1. **No exploration** — The “do NOT list, glob, or read” line explicitly covers “entity-extraction flow” so the agent uses only the recipe and quick reference for storing extracted entities and linking them to the message, without opening tool schemas.
2. **Unified store (one call)** — The “Entity-extraction turn (one call preferred)” recipe specifies a single `store_structured` with three entities (conversation, agent_message, extracted entity) and two relationships (PART_OF message→conversation, REFERS_TO message→extracted entity). That reduces three tool calls to one. Response paths are explicit: `Response.entities[0]`, `[1]`, `[2]`.
3. **Schema-agnostic extracted entities** — The recipe tells the agent to use a descriptive entity_type and whatever properties the message implies (no fixed schema) and "Do not call list_entity_types before storing; do not reason about schema," removing schema lookup and canonical-shape reasoning.
4. **create_relationship quick reference** — When a separate link is needed (e.g. multi-entity turn or fallback), one line gives the exact parameters and tells the agent to use `response.entities[N].entity_id` from a prior store; no schema read required.

## Related documents

- `docs/specs/MCP_SPEC.md` — Action catalog and entity type rules
- `docs/developer/mcp_overview.md` — Overview and setup
- `docs/developer/mcp/unauthenticated.md` — Unauthenticated instructions
- `docs/developer/mcp/tool_descriptions.yaml` — Per-tool descriptions
- `src/server.ts` — Loads this file via `getMcpInteractionInstructions()`
