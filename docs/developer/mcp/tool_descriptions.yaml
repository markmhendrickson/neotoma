# Per-tool descriptions for MCP ListTools response.
# Loaded at runtime by src/server.ts. Edit here to change tool copy without code changes.
# Keys must match tool names in server.ts. Parameter descriptions remain in code.

tools:
  retrieve_file_url: "Retrieve a signed URL for accessing a file"
  retrieve_entity_snapshot: "Retrieve the current snapshot of an entity with provenance information. Supports historical snapshots via 'at' parameter."
  list_observations: "List all observations for a given entity"
  retrieve_field_provenance: "Retrieve the provenance chain for a specific field in an entity snapshot"
  create_relationship: |
    Create a typed relationship between two entities. relationship_type: PART_OF, CORRECTS, REFERS_TO, SETTLES, DUPLICATE_OF, DEPENDS_ON, SUPERSEDES, or EMBEDS. Use EMBEDS when a container entity (e.g. blog post, document) embeds an asset entity (e.g. image, attachment): source_entity_id = container, target_entity_id = asset. For images/files stored in Neotoma: store the file via store (get source_id), create an image/media entity with source_id, then create_relationship(EMBEDS, post_entity_id, image_entity_id). Optional metadata: caption, order.
  list_relationships: "List relationships for an entity"
  get_relationship_snapshot: "Get the current snapshot of a specific relationship with provenance"
  retrieve_entities: "Query entities with filters (type, pagination). Returns entities with their snapshots. Supports optional search param for semantic similarity when embeddings configured."
  list_timeline_events: "Query timeline events with filters (type, date range, source). Returns chronological events derived from date fields in sources."
  retrieve_entity_by_identifier: "Retrieve entity by identifier (name, email, etc.) across entity types or specific type. Falls back to semantic search when keyword match returns no results."
  retrieve_related_entities: "Retrieve entities connected to a given entity via relationships. Supports n-hop traversal."
  retrieve_graph_neighborhood: "Retrieve complete graph neighborhood around a node (entity or source): related entities, relationships, sources, and events."
  store: |
    Unified storing for structured, unstructured, or combined payloads in one request. Choose path by source: file- or resource-sourced (attachment/file to preserve) → use file_content+mime_type or file_path; conversation- or tool-sourced (chat or other MCP) → use entities. You may send both entities and file input in the same call. In chat contexts, use store to persist conversation + turn message (and optional extracted entities) plus attachment file when present. Overwriting between branches is OK, history via list_observations. For unstructured (files): provide EITHER file_content (base64-encoded) + mime_type OR file_path (local file path). For structured (entities): provide entities array. When both are provided, response includes structured and unstructured sections. Content-addressed storage uses SHA-256 deduplication per user. IMPORTANT FOR UNSTRUCTURED FILES: Agents MUST NOT interpret or extract data before storing; pass raw file content/path only. The server handles interpretation when interpret=true (default). Re-storing the same file (same content or same idempotency_key) with interpret=true runs interpretation again (reinterpret); agents do not need to call reinterpret separately. IMPORTANT FOR STRUCTURED DATA: Include ALL fields from source data. Schema fields go to observations; non-schema fields go to raw_fragments for future schema expansion.
  store_structured: "Store structured entities only. Use for conversation- or tool-sourced data (e.g. from chat or another MCP). In chat: one call per turn with entities [conversation, agent_message], idempotency_key (per-store unique, e.g. conversation-{conversation_id}-{turn_id}-{timestamp_ms}), stable turn identity in agent_message (e.g. turn_key or id = conversation_id:turn_id), and relationships: [{ relationship_type: PART_OF, source_index: 1, target_index: 0 }]. Overwriting between branches is OK; history via list_observations. Use when you already have entity objects and do not need file ingestion."
  store_unstructured: "Store raw files only. Use when data is file- or resource-sourced (user attachment or file to preserve). Provide file_content (base64) + mime_type or file_path. Re-storing the same file (same content or same idempotency_key) with interpret=true runs interpretation again (reinterpret); agents do not need to call reinterpret separately."
  reinterpret: "Re-run AI interpretation on an existing source with new config. Creates new observations without modifying existing ones."
  interpret_uninterpreted: "Interpret stored sources that currently have no interpretation runs. Supports limit and dry_run for safe backfills."
  correct: "Create high-priority correction observation to override AI-extracted fields. Corrections always win in snapshot computation."
  merge_entities: "Merge duplicate entities. Rewrites observations from source entity to target entity and marks source as merged."
  delete_entity: "Delete an entity. Creates a deletion observation so the entity is excluded from snapshots and queries. Immutable and reversible for audit; use for user-initiated or GDPR-style removal from active use."
  delete_relationship: "Delete a relationship. Creates a deletion observation so the relationship is excluded from snapshots and queries. Immutable and reversible for audit."
  restore_entity: "Restore a deleted entity. Creates a restoration observation (priority 1001) that overrides the deletion. Entity becomes visible in snapshots and queries again. Immutable restoration for audit."
  restore_relationship: "Restore a deleted relationship. Creates a restoration observation (priority 1001) that overrides the deletion. Relationship becomes visible in snapshots and queries again. Immutable restoration for audit."
  list_entity_types: |
    List available entity types. Without keyword: returns a short summary (entity_type, schema_version, field_count) for all types. With keyword: returns full schema (field_names, field_summary) for matching types; pass summary: true to get summary only. Uses hybrid search when keyword is provided: keyword matching first, then vector semantic search. Use before storing structured data to determine the correct entity_type.
  analyze_schema_candidates: |
    Analyze raw_fragments to identify fields that should be promoted to schema fields. Returns recommendations with confidence scores based on frequency and type consistency.
  get_schema_recommendations: "Get schema update recommendations for an entity type from raw_fragments analysis, agent suggestions, or inference."
  update_schema_incremental: |
    Incrementally update a schema by adding new fields from raw_fragments or agent recommendations. Creates new schema version and activates it immediately, so all new data stored after this call will use the updated schema. Optionally migrates existing raw_fragments to observations for historical data backfill.
  register_schema: "Register a new schema or schema version. Supports both global and user-specific schemas."
  get_authenticated_user: "Get the authenticated user ID for the current MCP session. Returns the user_id that is automatically used for all authenticated actions."
  health_check_snapshots: "Check for stale entity snapshots (snapshots with observation_count=0 but observations exist). Returns health status and count of stale snapshots."
  npm_check_update: "Check if a newer npm version is available. Returns updateAvailable, message, and suggestedCommand. Call at session start to encourage user to upgrade."